# Complete Java OOP Guide with Interview Questions
## دليل شامل لبرمجة جافا الكائنية مع أسئلة المقابلات

---

## Table of Contents / فهرس المحتويات

1. [Java Basics / أساسيات جافا](#java-basics)
2. [Classes and Objects / الفئات والكائنات](#classes-and-objects)
3. [Encapsulation / التغليف](#encapsulation)
4. [Inheritance / الوراثة](#inheritance)
5. [Polymorphism / تعدد الأشكال](#polymorphism)
6. [Abstraction / التجريد](#abstraction)
7. [Interfaces / الواجهات](#interfaces)
8. [Exception Handling / معالجة الاستثناءات](#exception-handling)
9. [Collections Framework / إطار العمل للمجموعات](#collections)
10. [Generics / الأنواع العامة](#generics)
11. [Multithreading / البرمجة متعددة الخيوط](#multithreading)
12. [Interview Questions / أسئلة المقابلات](#interview-questions)

---

## Java Basics / أساسيات جافا

### What is Java? / ما هي جافا؟

**English:** Java is a high-level, object-oriented programming language developed by Sun Microsystems (now Oracle). It follows the principle "Write Once, Run Anywhere" (WORA).

**Arabic:** جافا هي لغة برمجة عالية المستوى وكائنية التوجه طورتها شركة Sun Microsystems (الآن Oracle). تتبع مبدأ "اكتب مرة واحدة، شغل في أي مكان".

### Key Features of Java / الميزات الرئيسية لجافا

**English Features:**
- Platform Independent
- Object-Oriented
- Simple and Secure
- Robust and Portable
- Multithreaded
- Interpreted and Dynamic

**Arabic Features / الميزات بالعربية:**
- مستقلة عن المنصة
- كائنية التوجه
- بسيطة وآمنة
- قوية ومحمولة
- متعددة الخيوط
- مفسرة وديناميكية

### Java Memory Management / إدارة الذاكرة في جافا

**Stack Memory:**
```
[Method Calls]
[Local Variables]
[Reference Variables]
```

**Heap Memory:**
```
[Objects]
[Instance Variables]
[Arrays]
```

---

## Classes and Objects / الفئات والكائنات

### What is a Class? / ما هي الفئة؟

**English:** A class is a blueprint or template for creating objects. It defines the structure and behavior of objects.

**Arabic:** الفئة هي مخطط أو قالب لإنشاء الكائنات. تحدد هيكل وسلوك الكائنات.

### Class Structure / هيكل الفئة

```java
// English Example
public class Car {
    // Instance variables (attributes)
    private String brand;
    private String model;
    private int year;
    
    // Constructor
    public Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }
    
    // Methods (behavior)
    public void start() {
        System.out.println("Car is starting...");
    }
    
    public void stop() {
        System.out.println("Car is stopping...");
    }
    
    // Getters and Setters
    public String getBrand() {
        return brand;
    }
    
    public void setBrand(String brand) {
        this.brand = brand;
    }
}
```

```java
// Arabic Example / مثال بالعربية
public class طالب {
    // متغيرات الكائن (الخصائص)
    private String الاسم;
    private int العمر;
    private String التخصص;
    
    // المنشئ
    public طالب(String الاسم, int العمر, String التخصص) {
        this.الاسم = الاسم;
        this.العمر = العمر;
        this.التخصص = التخصص;
    }
    
    // الطرق (السلوك)
    public void دراسة() {
        System.out.println(الاسم + " يدرس " + التخصص);
    }
}
```

### Object Creation / إنشاء الكائنات

```java
// Creating objects
Car car1 = new Car("Toyota", "Camry", 2023);
Car car2 = new Car("Honda", "Civic", 2022);

// Using objects
car1.start();
car2.stop();
```

### Constructor Types / أنواع المنشئات

**1. Default Constructor / المنشئ الافتراضي**
```java
public class Student {
    private String name;
    
    // Default constructor
    public Student() {
        this.name = "Unknown";
    }
}
```

**2. Parameterized Constructor / المنشئ المُحدد بمعاملات**
```java
public class Student {
    private String name;
    private int age;
    
    // Parameterized constructor
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

**3. Copy Constructor / المنشئ النسخي**
```java
public class Student {
    private String name;
    private int age;
    
    // Copy constructor
    public Student(Student other) {
        this.name = other.name;
        this.age = other.age;
    }
}
```

---

## Encapsulation / التغليف

### Definition / التعريف

**English:** Encapsulation is the mechanism of wrapping data (variables) and methods together as a single unit and hiding the internal implementation details.

**Arabic:** التغليف هو آلية تجميع البيانات (المتغيرات) والطرق معاً كوحدة واحدة وإخفاء تفاصيل التنفيذ الداخلية.

### Access Modifiers / محددات الوصول

```java
public class EncapsulationExample {
    public String publicVar;      // Accessible everywhere
    protected String protectedVar; // Accessible within package and subclasses
    String defaultVar;            // Accessible within package (default)
    private String privateVar;    // Accessible only within class
    
    // Private method
    private void privateMethod() {
        System.out.println("Private method");
    }
    
    // Public method to access private data
    public String getPrivateVar() {
        return privateVar;
    }
    
    public void setPrivateVar(String privateVar) {
        if (privateVar != null && !privateVar.isEmpty()) {
            this.privateVar = privateVar;
        }
    }
}
```

### Benefits of Encapsulation / فوائد التغليف

**English Benefits:**
- Data hiding and security
- Control over data access
- Code flexibility and maintainability
- Implementation can be changed without affecting other classes

**Arabic Benefits / الفوائد بالعربية:**
- إخفاء البيانات والأمان
- التحكم في الوصول للبيانات
- مرونة الكود وسهولة الصيانة
- يمكن تغيير التنفيذ دون تأثير على الفئات الأخرى

---

## Inheritance / الوراثة

### Definition / التعريف

**English:** Inheritance is a mechanism where a new class (child/subclass) acquires properties and behaviors of an existing class (parent/superclass).

**Arabic:** الوراثة هي آلية حيث تكتسب فئة جديدة (فئة فرعية) خصائص وسلوكيات فئة موجودة (فئة أساسية).

### Types of Inheritance / أنواع الوراثة

**1. Single Inheritance / الوراثة الفردية**
```java
// Parent class / الفئة الأساسية
class Animal {
    protected String name;
    protected int age;
    
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void eat() {
        System.out.println(name + " is eating");
    }
    
    public void sleep() {
        System.out.println(name + " is sleeping");
    }
}

// Child class / الفئة الفرعية
class Dog extends Animal {
    private String breed;
    
    public Dog(String name, int age, String breed) {
        super(name, age); // Call parent constructor
        this.breed = breed;
    }
    
    public void bark() {
        System.out.println(name + " is barking");
    }
    
    // Method overriding
    @Override
    public void eat() {
        System.out.println(name + " the dog is eating dog food");
    }
}
```

**2. Multilevel Inheritance / الوراثة متعددة المستويات**
```java
class Animal {
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Mammal extends Animal {
    public void breathe() {
        System.out.println("Mammal breathes");
    }
}

class Dog extends Mammal {
    public void bark() {
        System.out.println("Dog barks");
    }
}
```

**3. Hierarchical Inheritance / الوراثة الهرمية**
```java
class Animal {
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat meows");
    }
}

class Bird extends Animal {
    public void fly() {
        System.out.println("Bird flies");
    }
}
```

### Method Overriding / تجاوز الطرق

```java
class Vehicle {
    public void start() {
        System.out.println("Vehicle is starting");
    }
    
    public final void stop() {
        System.out.println("Vehicle is stopping");
    }
}

class Car extends Vehicle {
    @Override
    public void start() {
        System.out.println("Car engine is starting");
    }
    
    // Cannot override final method
    // public void stop() { } // This would cause compilation error
}
```

### Super Keyword / كلمة super

```java
class Parent {
    protected String name = "Parent";
    
    public Parent() {
        System.out.println("Parent constructor");
    }
    
    public void display() {
        System.out.println("Parent display method");
    }
}

class Child extends Parent {
    private String name = "Child";
    
    public Child() {
        super(); // Call parent constructor
        System.out.println("Child constructor");
    }
    
    public void display() {
        super.display(); // Call parent method
        System.out.println("Child display method");
        System.out.println("Parent name: " + super.name);
        System.out.println("Child name: " + this.name);
    }
}
```

---

## Polymorphism / تعدد الأشكال

### Definition / التعريف

**English:** Polymorphism means "many forms." It allows objects of different types to be treated as objects of a common base type.

**Arabic:** تعدد الأشكال يعني "أشكال متعددة". يسمح للكائنات من أنواع مختلفة أن تُعامل ككائنات من نوع أساسي مشترك.

### Types of Polymorphism / أنواع تعدد الأشكال

**1. Compile-time Polymorphism (Method Overloading) / تعدد الأشكال وقت الترجمة**
```java
class Calculator {
    // Method overloading - same name, different parameters
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
}
```

**2. Runtime Polymorphism (Method Overriding) / تعدد الأشكال وقت التشغيل**
```java
abstract class Shape {
    public abstract void draw();
    public abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a circle");
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a rectangle");
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

// Polymorphic behavior
public class PolymorphismDemo {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle(5),
            new Rectangle(4, 6),
            new Circle(3)
        };
        
        for (Shape shape : shapes) {
            shape.draw(); // Polymorphic method call
            System.out.println("Area: " + shape.calculateArea());
        }
    }
}
```

### Dynamic Method Dispatch / إرسال الطرق الديناميكي

```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows");
    }
}

public class DynamicMethodDispatch {
    public static void main(String[] args) {
        Animal animal; // Reference variable
        
        animal = new Dog();
        animal.makeSound(); // Output: Dog barks
        
        animal = new Cat();
        animal.makeSound(); // Output: Cat meows
    }
}
```

---

## Abstraction / التجريد

### Definition / التعريف

**English:** Abstraction is the process of hiding implementation details while showing only the essential features of an object.

**Arabic:** التجريد هو عملية إخفاء تفاصيل التنفيذ مع إظهار الميزات الأساسية للكائن فقط.

### Abstract Classes / الفئات المجردة

```java
abstract class Vehicle {
    protected String brand;
    protected String model;
    
    public Vehicle(String brand, String model) {
        this.brand = brand;
        this.model = model;
    }
    
    // Abstract method - must be implemented by subclasses
    public abstract void start();
    public abstract void stop();
    
    // Concrete method - can be used by subclasses
    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Model: " + model);
    }
}

class Car extends Vehicle {
    public Car(String brand, String model) {
        super(brand, model);
    }
    
    @Override
    public void start() {
        System.out.println("Car engine started with key");
    }
    
    @Override
    public void stop() {
        System.out.println("Car engine stopped");
    }
}

class Motorcycle extends Vehicle {
    public Motorcycle(String brand, String model) {
        super(brand, model);
    }
    
    @Override
    public void start() {
        System.out.println("Motorcycle started with kick/button");
    }
    
    @Override
    public void stop() {
        System.out.println("Motorcycle stopped");
    }
}
```

### Rules for Abstract Classes / قواعد الفئات المجردة

**English Rules:**
- Cannot be instantiated directly
- Can have both abstract and concrete methods
- Can have constructors
- Can have instance variables
- Subclasses must implement all abstract methods

**Arabic Rules / القواعد بالعربية:**
- لا يمكن إنشاء كائنات منها مباشرة
- يمكن أن تحتوي على طرق مجردة وملموسة
- يمكن أن تحتوي على منشئات
- يمكن أن تحتوي على متغيرات الكائن
- الفئات الفرعية يجب أن تنفذ جميع الطرق المجردة

---

## Interfaces / الواجهات

### Definition / التعريف

**English:** An interface is a contract that defines what a class can do, without specifying how it does it. It contains only method signatures and constants.

**Arabic:** الواجهة هي عقد يحدد ما يمكن للفئة أن تفعله، دون تحديد كيفية فعل ذلك. تحتوي على تواقيع الطرق والثوابت فقط.

### Interface Declaration / إعلان الواجهة

```java
// Interface definition
interface Drawable {
    // All methods in interface are public and abstract by default
    void draw();
    void resize(double factor);
    
    // Constants are public, static, and final by default
    String DEFAULT_COLOR = "BLACK";
    int MAX_SIZE = 1000;
}

interface Colorable {
    void setColor(String color);
    String getColor();
}

// Multiple interface implementation
class Circle implements Drawable, Colorable {
    private double radius;
    private String color;
    
    public Circle(double radius) {
        this.radius = radius;
        this.color = Drawable.DEFAULT_COLOR;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a circle with radius: " + radius);
    }
    
    @Override
    public void resize(double factor) {
        radius *= factor;
        System.out.println("Circle resized to radius: " + radius);
    }
    
    @Override
    public void setColor(String color) {
        this.color = color;
    }
    
    @Override
    public String getColor() {
        return color;
    }
}
```

### Default and Static Methods in Interfaces / الطرق الافتراضية والثابتة في الواجهات

```java
interface Vehicle {
    // Abstract method
    void start();
    
    // Default method (Java 8+)
    default void honk() {
        System.out.println("Beep beep!");
    }
    
    // Static method (Java 8+)
    static void checkFuel() {
        System.out.println("Checking fuel level...");
    }
    
    // Private method (Java 9+)
    private void log(String message) {
        System.out.println("Log: " + message);
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car started");
    }
    
    // Can override default method
    @Override
    public void honk() {
        System.out.println("Car horn: Honk honk!");
    }
}
```

### Functional Interfaces / الواجهات الوظيفية

```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // Can have default and static methods
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }
}

// Lambda expression usage
public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        Calculator add = (a, b) -> a + b;
        Calculator multiply = (a, b) -> a * b;
        
        System.out.println(add.calculate(5, 3)); // Output: 8
        System.out.println(multiply.calculate(5, 3)); // Output: 15
    }
}
```

### Interface vs Abstract Class / الواجهة مقابل الفئة المجردة

| Feature | Interface | Abstract Class |
|---------|-----------|----------------|
| Methods | Abstract, default, static | Abstract and concrete |
| Variables | public, static, final | Any access modifier |
| Inheritance | Multiple inheritance | Single inheritance |
| Constructor | No constructor | Can have constructor |
| Access modifiers | public by default | Any access modifier |

---

## Exception Handling / معالجة الاستثناءات

### Definition / التعريف

**English:** Exception handling is a mechanism to handle runtime errors, maintaining the normal flow of application execution.

**Arabic:** معالجة الاستثناءات هي آلية للتعامل مع أخطاء وقت التشغيل، مع الحفاظ على التدفق الطبيعي لتنفيذ التطبيق.

### Exception Hierarchy / تدرج الاستثناءات

```
Throwable
├── Error (System errors)
└── Exception
    ├── RuntimeException (Unchecked)
    │   ├── NullPointerException
    │   ├── ArrayIndexOutOfBoundsException
    │   ├── IllegalArgumentException
    │   └── NumberFormatException
    └── Checked Exceptions
        ├── IOException
        ├── SQLException
        └── ClassNotFoundException
```

### Try-Catch-Finally / محاولة-التقاط-أخيراً

```java
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        try {
            // Code that might throw an exception
            int[] numbers = {1, 2, 3};
            System.out.println(numbers[5]); // ArrayIndexOutOfBoundsException
            
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index out of bounds: " + e.getMessage());
            
        } catch (Exception e) {
            System.out.println("General exception: " + e.getMessage());
            
        } finally {
            System.out.println("This block always executes");
        }
    }
}
```

### Multiple Catch Blocks / كتل التقاط متعددة

```java
public class MultipleCatchExample {
    public static void divideNumbers(String num1, String num2) {
        try {
            int a = Integer.parseInt(num1);
            int b = Integer.parseInt(num2);
            int result = a / b;
            System.out.println("Result: " + result);
            
        } catch (NumberFormatException e) {
            System.out.println("Invalid number format: " + e.getMessage());
            
        } catch (ArithmeticException e) {
            System.out.println("Division by zero: " + e.getMessage());
            
        } catch (Exception e) {
            System.out.println("Unexpected error: " + e.getMessage());
        }
    }
}
```

### Throw and Throws / رمي والرماة

```java
public class CustomExceptionExample {
    
    // Method that throws an exception
    public static void validateAge(int age) throws IllegalArgumentException {
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("Invalid age: " + age);
        }
        System.out.println("Valid age: " + age);
    }
    
    // Method with checked exception
    public static void readFile(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        // File reading code
        reader.close();
    }
    
    public static void main(String[] args) {
        try {
            validateAge(-5);
        } catch (IllegalArgumentException e) {
            System.out.println("Caught exception: " + e.getMessage());
        }
        
        try {
            readFile("nonexistent.txt");
        } catch (IOException e) {
            System.out.println("File error: " + e.getMessage());
        }
    }
}
```

### Custom Exceptions / الاستثناءات المخصصة

```java
// Custom checked exception
class InsufficientBalanceException extends Exception {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

// Custom unchecked exception
class InvalidAccountException extends RuntimeException {
    public InvalidAccountException(String message) {
        super(message);
    }
}

class BankAccount {
    private double balance;
    private String accountNumber;
    
    public BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
    
    public void withdraw(double amount) throws InsufficientBalanceException {
        if (amount > balance) {
            throw new InsufficientBalanceException(
                "Insufficient balance. Available: " + balance + ", Requested: " + amount
            );
        }
        balance -= amount;
        System.out.println("Withdrawal successful. New balance: " + balance);
    }
    
    public void validateAccount() {
        if (accountNumber == null || accountNumber.length() < 8) {
            throw new InvalidAccountException("Invalid account number");
        }
    }
}
```

---

## Collections Framework / إطار العمل للمجموعات

### Definition / التعريف

**English:** The Collections Framework is a set of classes and interfaces that implement commonly reusable collection data structures.

**Arabic:** إطار العمل للمجموعات هو مجموعة من الفئات والواجهات التي تنفذ هياكل بيانات المجموعات القابلة لإعادة الاستخدام.

### Collection Hierarchy / تدرج المجموعات

```
Collection (Interface)
├── List (Interface)
│   ├── ArrayList (Class)
│   ├── LinkedList (Class)
│   └── Vector (Class)
├── Set (Interface)
│   ├── HashSet (Class)
│   ├── LinkedHashSet (Class)
│   └── TreeSet (Class)
└── Queue (Interface)
    ├── LinkedList (Class)
    ├── PriorityQueue (Class)
    └── ArrayDeque (Class)

Map (Interface)
├── HashMap (Class)
├── LinkedHashMap (Class)
├── TreeMap (Class)
└── Hashtable (Class)
```

### ArrayList / قائمة المصفوفة

```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        // Creating ArrayList
        ArrayList<String> fruits = new ArrayList<>();
        
        // Adding elements
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        fruits.add(1, "Mango"); // Insert at index 1
        
        // Accessing elements
        System.out.println("First fruit: " + fruits.get(0));
        System.out.println("Size: " + fruits.size());
        
        // Iterating
        System.out.println("All fruits:");
        for (String fruit : fruits) {
            System.out.println("- " + fruit);
        }
        
        // Using iterator
        Iterator<String> iter = fruits.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
        
        // Removing elements
        fruits.remove("Banana");
        fruits.remove(0); // Remove by index
        
        // Checking if contains
        if (fruits.contains("Apple")) {
            System.out.println("Apple found!");
        }
    }
}
```

### LinkedList / القائمة المرتبطة

```java
import java.util.*;

public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<Integer> numbers = new LinkedList<>();
        
        // Adding elements
        numbers.add(10);
        numbers.add(20);
        numbers.addFirst(5);  // Add to beginning
        numbers.addLast(30);  // Add to end
        
        // LinkedList as Stack
        numbers.push(1);      // Add to beginning
        int first = numbers.pop(); // Remove from beginning
        
        // LinkedList as Queue
        numbers.offer(40);    // Add to end
        int head = numbers.poll(); // Remove from beginning
        
        System.out.println("LinkedList: " + numbers);
    }
}
```

### HashSet / مجموعة التجمع

```java
import java.util.*;

public class HashSetExample {
    public static void main(String[] args) {
        HashSet<String> countries = new HashSet<>();
        
        // Adding elements (no duplicates)
        countries.add("USA");
        countries.add("UK");
        countries.add("Canada");
        countries.add("USA"); // Duplicate - won't be added
        
        System.out.println("Countries: " + countries);
        System.out.println("Size: " + countries.size()); // Size: 3
        
        // Set operations
        HashSet<String> europeanCountries = new HashSet<>();
        europeanCountries.add("UK");
        europeanCountries.add("France");
        europeanCountries.add("Germany");
        
        // Union
        HashSet<String> allCountries = new HashSet<>(countries);
        allCountries.addAll(europeanCountries);
        
        // Intersection
        HashSet<String> commonCountries = new HashSet<>(countries);
        commonCountries.retainAll(europeanCountries);
        
        System.out.println("All countries: " + allCountries);
        System.out.println("Common countries: " + commonCountries);
    }
}
```

### HashMap / خريطة التجمع

```java
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, Integer> studentGrades = new HashMap<>();
        
        // Adding key-value pairs
        studentGrades.put("Alice", 95);
        studentGrades.put("Bob", 87);
        studentGrades.put("Charlie", 92);
        studentGrades.put("Alice", 98); // Updates existing value
        
        // Accessing values
        System.out.println("Alice's grade: " + studentGrades.get("Alice"));
        
        // Iterating over entries
        for (Map.Entry<String, Integer> entry : studentGrades.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Iterating over keys
        for (String name : studentGrades.keySet()) {
            System.out.println(name + " scored " + studentGrades.get(name));
        }
        
        // Iterating over values
        for (Integer grade : studentGrades.values()) {
            System.out.println("Grade: " + grade);
        }
        
        // Checking if key/value exists
        if (studentGrades.containsKey("Bob")) {
            System.out.println("Bob is in the map");
        }
        
        if (studentGrades.containsValue(95)) {
            System.out.println("Someone got 95");
        }
        
        // Removing elements
        studentGrades.remove("Charlie");
        
        System.out.println("Final grades: " + studentGrades);
    }
}
```

### TreeMap / خريطة الشجرة

```java
import java.util.*;

public class TreeMapExample {
    public static void main(String[] args) {
        // TreeMap keeps keys in sorted order
        TreeMap<String, Double> productPrices = new TreeMap<>();
        
        productPrices.put("Laptop", 999.99);
        productPrices.put("Mouse", 25.50);
        productPrices.put("Keyboard", 75.00);
        productPrices.put("Monitor", 299.99);
        
        // Keys are automatically sorted
        System.out.println("Products (sorted): " + productPrices);
        
        // Navigation methods
        System.out.println("First product: " + productPrices.firstKey());
        System.out.println("Last product: " + productPrices.lastKey());
        
        // Range operations
        System.out.println("Products from K to M: " + 
                         productPrices.subMap("K", "N"));
    }
}
```

---

## Generics / الأنواع العامة

### Definition / التعريف

**English:** Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. They provide type safety and eliminate the need for casting.

**Arabic:** الأنواع العامة تمكن الأنواع (الفئات والواجهات) من أن تكون معاملات عند تعريف الفئات والواجهات والطرق. توفر أمان النوع وتلغي الحاجة للتحويل.

### Generic Classes / الفئات العامة

```java
// Generic class with single type parameter
public class Box<T> {
    private T content;
    
    public void setContent(T content) {
        this.content = content;
    }
    
    public T getContent() {
        return content;
    }
    
    public void displayType() {
        System.out.println("Type: " + content.getClass().getSimpleName());
    }
}

// Generic class with multiple type parameters
public class Pair<T, U> {
    private T first;
    private U second;
    
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
    
    public T getFirst() {
        return first;
    }
    
    public U getSecond() {
        return second;
    }
    
    @Override
    public String toString() {
        return "Pair{first=" + first + ", second=" + second + "}";
    }
}

// Usage example
public class GenericExample {
    public static void main(String[] args) {
        // String Box
        Box<String> stringBox = new Box<>();
        stringBox.setContent("Hello Generics");
        System.out.println(stringBox.getContent());
        
        // Integer Box
        Box<Integer> intBox = new Box<>();
        intBox.setContent(42);
        System.out.println(intBox.getContent());
        
        // Pair examples
        Pair<String, Integer> nameAge = new Pair<>("Alice", 25);
        Pair<Double, String> priceItem = new Pair<>(29.99, "Book");
        
        System.out.println(nameAge);
        System.out.println(priceItem);
    }
}
```

### Generic Methods / الطرق العامة

```java
public class GenericMethods {
    
    // Generic method
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    // Generic method with bounded type parameter
    public static <T extends Number> double sum(T[] numbers) {
        double total = 0.0;
        for (T num : numbers) {
            total += num.doubleValue();
        }
        return total;
    }
    
    // Generic method with multiple bounds
    public static <T extends Number & Comparable<T>> T findMax(T[] array) {
        if (array.length == 0) return null;
        
        T max = array[0];
        for (T element : array) {
            if (element.compareTo(max) > 0) {
                max = element;
            }
        }
        return max;
    }
    
    public static void main(String[] args) {
        // Using generic swap method
        String[] names = {"Alice", "Bob", "Charlie"};
        System.out.println("Before swap: " + Arrays.toString(names));
        swap(names, 0, 2);
        System.out.println("After swap: " + Arrays.toString(names));
        
        // Using bounded generic method
        Integer[] numbers = {1, 2, 3, 4, 5};
        System.out.println("Sum: " + sum(numbers));
        System.out.println("Max: " + findMax(numbers));
    }
}
```

### Wildcards / الأحرف البديلة

```java
import java.util.*;

public class WildcardExample {
    
    // Upper bounded wildcard (? extends T)
    public static double sumNumbers(List<? extends Number> numbers) {
        double sum = 0.0;
        for (Number num : numbers) {
            sum += num.doubleValue();
        }
        return sum;
    }
    
    // Lower bounded wildcard (? super T)
    public static void addNumbers(List<? super Integer> numbers) {
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
    }
    
    // Unbounded wildcard (?)
    public static void printList(List<?> list) {
        for (Object item : list) {
            System.out.println(item);
        }
    }
    
    public static void main(String[] args) {
        // Upper bounded example
        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);
        List<Double> doubleList = Arrays.asList(1.5, 2.5, 3.5);
        
        System.out.println("Sum of integers: " + sumNumbers(intList));
        System.out.println("Sum of doubles: " + sumNumbers(doubleList));
        
        // Lower bounded example
        List<Number> numberList = new ArrayList<>();
        addNumbers(numberList);
        System.out.println("Numbers: " + numberList);
        
        // Unbounded example
        printList(intList);
        printList(Arrays.asList("A", "B", "C"));
    }
}
```

---

## Multithreading / البرمجة متعددة الخيوط

### Definition / التعريف

**English:** Multithreading is the ability of a program to execute multiple threads concurrently, allowing multiple tasks to run simultaneously.

**Arabic:** البرمجة متعددة الخيوط هي قدرة البرنامج على تنفيذ خيوط متعددة بشكل متزامن، مما يسمح لمهام متعددة بالعمل في نفس الوقت.

### Creating Threads / إنشاء الخيوط

**Method 1: Extending Thread Class / الطريقة الأولى: وراثة فئة Thread**

```java
class MyThread extends Thread {
    private String threadName;
    
    public MyThread(String name) {
        this.threadName = name;
    }
    
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(threadName + " - Count: " + i);
            try {
                Thread.sleep(1000); // Sleep for 1 second
            } catch (InterruptedException e) {
                System.out.println(threadName + " interrupted");
            }
        }
        System.out.println(threadName + " finished");
    }
}

public class ThreadExample1 {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread("Thread-1");
        MyThread thread2 = new MyThread("Thread-2");
        
        thread1.start();
        thread2.start();
        
        System.out.println("Main thread continues...");
    }
}
```

**Method 2: Implementing Runnable Interface / الطريقة الثانية: تنفيذ واجهة Runnable**

```java
class MyRunnable implements Runnable {
    private String taskName;
    
    public MyRunnable(String name) {
        this.taskName = name;
    }
    
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(taskName + " - Count: " + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(taskName + " interrupted");
            }
        }
        System.out.println(taskName + " completed");
    }
}

public class ThreadExample2 {
    public static void main(String[] args) {
        MyRunnable task1 = new MyRunnable("Task-1");
        MyRunnable task2 = new MyRunnable("Task-2");
        
        Thread thread1 = new Thread(task1);
        Thread thread2 = new Thread(task2);
        
        thread1.start();
        thread2.start();
        
        // Using lambda expression
        Thread thread3 = new Thread(() -> {
            for (int i = 1; i <= 3; i++) {
                System.out.println("Lambda Thread - " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        thread3.start();
    }
}
```

### Thread Synchronization / تزامن الخيوط

```java
class Counter {
    private int count = 0;
    
    // Synchronized method
    public synchronized void increment() {
        count++;
    }
    
    // Synchronized block
    public void incrementBlock() {
        synchronized(this) {
            count++;
        }
    }
    
    public synchronized int getCount() {
        return count;
    }
}

class CounterTask implements Runnable {
    private Counter counter;
    private String threadName;
    
    public CounterTask(Counter counter, String name) {
        this.counter = counter;
        this.threadName = name;
    }
    
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
        System.out.println(threadName + " finished counting");
    }
}

public class SynchronizationExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        
        Thread thread1 = new Thread(new CounterTask(counter, "Thread-1"));
        Thread thread2 = new Thread(new CounterTask(counter, "Thread-2"));
        Thread thread3 = new Thread(new CounterTask(counter, "Thread-3"));
        
        thread1.start();
        thread2.start();
        thread3.start();
        
        // Wait for all threads to complete
        thread1.join();
        thread2.join();
        thread3.join();
        
        System.out.println("Final count: " + counter.getCount());
    }
}
```

### Producer-Consumer Problem / مشكلة المنتج والمستهلك

```java
import java.util.*;

class Buffer {
    private Queue<Integer> queue = new LinkedList<>();
    private int capacity;
    
    public Buffer(int capacity) {
        this.capacity = capacity;
    }
    
    public synchronized void produce(int item) throws InterruptedException {
        while (queue.size() == capacity) {
            wait(); // Wait if buffer is full
        }
        
        queue.add(item);
        System.out.println("Produced: " + item + " | Buffer size: " + queue.size());
        notify(); // Notify consumers
    }
    
    public synchronized int consume() throws InterruptedException {
        while (queue.isEmpty()) {
            wait(); // Wait if buffer is empty
        }
        
        int item = queue.poll();
        System.out.println("Consumed: " + item + " | Buffer size: " + queue.size());
        notify(); // Notify producers
        return item;
    }
}

class Producer implements Runnable {
    private Buffer buffer;
    
    public Producer(Buffer buffer) {
        this.buffer = buffer;
    }
    
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                buffer.produce(i);
                Thread.sleep(100);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

class Consumer implements Runnable {
    private Buffer buffer;
    
    public Consumer(Buffer buffer) {
        this.buffer = buffer;
    }
    
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                buffer.consume();
                Thread.sleep(150);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public class ProducerConsumerExample {
    public static void main(String[] args) {
        Buffer buffer = new Buffer(5);
        
        Thread producer = new Thread(new Producer(buffer));
        Thread consumer = new Thread(new Consumer(buffer));
        
        producer.start();
        consumer.start();
    }
}
```

---

## Interview Questions / أسئلة المقابلات

### Basic Level Questions / أسئلة المستوى الأساسي

**Q1: What is Object-Oriented Programming? / ما هي البرمجة كائنية التوجه؟**

**English Answer:** Object-Oriented Programming (OOP) is a programming paradigm based on the concept of objects, which contain data (attributes) and code (methods). The main principles of OOP are:
- Encapsulation: Bundling data and methods together
- Inheritance: Creating new classes based on existing ones
- Polymorphism: Same interface, different implementations
- Abstraction: Hiding implementation details

**Arabic Answer:** البرمجة كائنية التوجه هي نموذج برمجة يعتمد على مفهوم الكائنات التي تحتوي على بيانات (خصائص) وكود (طرق). المبادئ الرئيسية هي:
- التغليف: تجميع البيانات والطرق معاً
- الوراثة: إنشاء فئات جديدة بناءً على فئات موجودة
- تعدد الأشكال: نفس الواجهة، تنفيذات مختلفة
- التجريد: إخفاء تفاصيل التنفيذ

**Q2: What is the difference between Class and Object? / ما الفرق بين الفئة والكائن؟**

**English Answer:**
- **Class**: A blueprint or template that defines the structure and behavior of objects
- **Object**: An instance of a class, actual entity created from the class template

Example:
```java
class Car {  // This is a class
    String brand;
    void start() { }
}

Car myCar = new Car();  // This is an object
```

**Arabic Answer:**
- **الفئة**: مخطط أو قالب يحدد هيكل وسلوك الكائنات
- **الكائن**: نسخة من الفئة، كيان فعلي تم إنشاؤه من قالب الفئة

**Q3: Explain the types of constructors in Java / اشرح أنواع المنشئات في جافا**

**English Answer:**
1. **Default Constructor**: No parameters, provided automatically if no constructor is defined
2. **Parameterized Constructor**: Takes parameters to initialize object with specific values
3. **Copy Constructor**: Creates object by copying another object (not built-in in Java)

```java
public class Student {
    private String name;
    private int age;
    
    // Default constructor
    public Student() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // Parameterized constructor
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Copy constructor
    public Student(Student other) {
        this.name = other.name;
        this.age = other.age;
    }
}
```

**Q4: What is method overloading and method overriding? / ما هو تحميل الطريقة وتجاوز الطريقة؟**

**English Answer:**
- **Method Overloading**: Multiple methods with same name but different parameters (compile-time polymorphism)
- **Method Overriding**: Subclass provides specific implementation of a method defined in parent class (runtime polymorphism)

```java
// Method Overloading
class Calculator {
    public int add(int a, int b) { return a + b; }
    public double add(double a, double b) { return a + b; }
    public int add(int a, int b, int c) { return a + b + c; }
}

// Method Overriding
class Animal {
    public void makeSound() { System.out.println("Animal sound"); }
}
class Dog extends Animal {
    @Override
    public void makeSound() { System.out.println("Bark"); }
}
```

**Q5: What is the difference between abstract class and interface? / ما الفرق بين الفئة المجردة والواجهة؟**

**English Answer:**

| Abstract Class | Interface |
|---------------|-----------|
| Can have both abstract and concrete methods | Only abstract methods (before Java 8) |
| Can have constructors | Cannot have constructors |
| Can have instance variables | Only constants (public static final) |
| Single inheritance | Multiple inheritance supported |
| Can have any access modifiers | Methods are public by default |

```java
// Abstract class
abstract class Vehicle {
    protected String brand;
    
    public Vehicle(String brand) {
        this.brand = brand;
    }
    
    public abstract void start();
    
    public void displayBrand() {
        System.out.println("Brand: " + brand);
    }
}

// Interface
interface Drivable {
    void drive();
    default void honk() {
        System.out.println("Honk!");
    }
}
```

### Intermediate Level Questions / أسئلة المستوى المتوسط

**Q6: Explain the concept of polymorphism with examples / اشرح مفهوم تعدد الأشكال مع أمثلة**

**English Answer:** Polymorphism allows objects of different types to be treated as objects of a common base type. There are two types:

1. **Compile-time Polymorphism (Method Overloading)**
2. **Runtime Polymorphism (Method Overriding)**

```java
// Runtime Polymorphism Example
abstract class Shape {
    public abstract void draw();
    public abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing Circle");
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

// Polymorphic behavior
public class PolymorphismDemo {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle(5),
            new Rectangle(4, 6),
            new Circle(3)
        };
        
        for (Shape shape : shapes) {
            shape.draw(); // Polymorphic method call
            System.out.println("Area: " + shape.calculateArea());
        }
    }
}
```

**Q7: What are generics and why are they important? / ما هي الأنواع العامة ولماذا هي مهمة؟**

**English Answer:** Generics enable types to be parameters when defining classes, interfaces, and methods. They provide:
- **Type Safety**: Compile-time type checking
- **Elimination of Casting**: No need for explicit casting
- **Code Reusability**: Same code works with different types

```java
// Without Generics (Old approach)
List list = new ArrayList();
list.add("Hello");
list.add(42); // Runtime error potential
String str = (String) list.get(0); // Explicit casting needed

// With Generics
List<String> stringList = new ArrayList<String>();
stringList.add("Hello");
// stringList.add(42); // Compile-time error
String str = stringList.get(0); // No casting needed
```

**Q8: Explain exception hierarchy in Java / اشرح تدرج الاستثناءات في جافا**

**English Answer:** Java exception hierarchy:

```
Throwable
├── Error (Unchecked - System level errors)
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   └── VirtualMachineError
└── Exception
    ├── RuntimeException (Unchecked Exceptions)
    │   ├── NullPointerException
    │   ├── ArrayIndexOutOfBoundsException
    │   ├── IllegalArgumentException
    │   └── NumberFormatException
    └── Checked Exceptions
        ├── IOException
        ├── SQLException
        ├── ClassNotFoundException
        └── FileNotFoundException
```

- **Checked Exceptions**: Must be handled or declared
- **Unchecked Exceptions**: Can be handled optionally
- **Errors**: System-level problems, usually not recoverable

**Q9: What is the difference between ArrayList and LinkedList? / ما الفرق بين ArrayList و LinkedList؟**

**English Answer:**

| ArrayList | LinkedList |
|-----------|------------|
| Dynamic array implementation | Doubly linked list implementation |
| Good for random access | Good for frequent insertions/deletions |
| O(1) access time by index | O(n) access time by index |
| O(n) insertion/deletion (middle) | O(1) insertion/deletion (if node known) |
| Less memory overhead | More memory overhead (node pointers) |
| Better cache performance | Poor cache performance |

```java
// ArrayList - Better for access
List<String> arrayList = new ArrayList<>();
arrayList.add("A");
String element = arrayList.get(0); // O(1) - Fast

// LinkedList - Better for insertions/deletions
List<String> linkedList = new LinkedList<>();
linkedList.add("A");
linkedList.add(0, "B"); // O(1) - Fast insertion at beginning
```

**Q10: Explain multithreading and synchronization / اشرح البرمجة متعددة الخيوط والتزامن**

**English Answer:** Multithreading allows concurrent execution of multiple threads. Key concepts:

1. **Thread Creation**: Extend Thread class or implement Runnable
2. **Synchronization**: Control access to shared resources
3. **Thread States**: NEW, RUNNABLE, BLOCKED, WAITING, TERMINATED

```java
// Thread creation
class MyThread extends Thread {
    public void run() {
        // Thread logic
    }
}

// Synchronization
class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++; // Thread-safe
    }
    
    public synchronized int getCount() {
        return count;
    }
}

// Thread coordination
public class ThreadExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new MyThread();
        Thread t2 = new MyThread();
        
        t1.start();
        t2.start();
        
        t1.join(); // Wait for t1 to complete
        t2.join(); // Wait for t2 to complete
    }
}
```

### Advanced Level Questions / أسئلة المستوى المتقدم

**Q11: Explain the concept of immutable objects in Java / اشرح مفهوم الكائنات غير القابلة للتغيير في جافا**

**English Answer:** Immutable objects cannot be modified after creation. Examples: String, Integer, LocalDate.

**Creating Immutable Class:**
```java
public final class ImmutablePerson {
    private final String name;
    private final int age;
    private final List<String> hobbies;
    
    public ImmutablePerson(String name, int age, List<String> hobbies) {
        this.name = name;
        this.age = age;
        // Defensive copy to prevent external modification
        this.hobbies = new ArrayList<>(hobbies);
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public List<String> getHobbies() {
        // Return defensive copy
        return new ArrayList<>(hobbies);
    }
    
    // No setter methods
}
```

**Benefits:**
- Thread-safe
- Can be safely shared
- Good hash code candidates
- Simplify debugging

**Q12: What is reflection in Java and how is it used? / ما هو الانعكاس في جافا وكيف يُستخدم؟**

**English Answer:** Reflection allows examining and modifying classes, methods, and fields at runtime.

```java
import java.lang.reflect.*;

public class ReflectionExample {
    private String name = "Test";
    private int value = 42;
    
    public void displayInfo() {
        System.out.println("Name: " + name + ", Value: " + value);
    }
    
    public static void main(String[] args) throws Exception {
        ReflectionExample obj = new ReflectionExample();
        Class<?> clazz = obj.getClass();
        
        // Get class information
        System.out.println("Class name: " + clazz.getName());
        
        // Get and invoke methods
        Method method = clazz.getMethod("displayInfo");
        method.invoke(obj);
        
        // Access private fields
        Field nameField = clazz.getDeclaredField("name");
        nameField.setAccessible(true);
        nameField.set(obj, "Modified");
        
        // Get constructors
        Constructor<?>[] constructors = clazz.getConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println("Constructor: " + constructor);
        }
    }
}
```

**Q13: Explain the difference between Comparable and Comparator / اشرح الفرق بين Comparable و Comparator**

**English Answer:**

**Comparable:** Natural ordering, implemented by the class itself
```java
public class Student implements Comparable<Student> {
    private String name;
    private int grade;
    
    public Student(String name, int grade) {
        this.name = name;
        this.grade = grade;
    }
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.grade, other.grade);
    }
    
    @Override
    public String toString() {
        return name + "(" + grade + ")";
    }
}
```

**Comparator:** Custom ordering, external to the class
```java
import java.util.*;

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", 85),
            new Student("Bob", 92),
            new Student("Charlie", 78)
        );
        
        // Using Comparable (natural ordering)
        Collections.sort(students);
        System.out.println("Sorted by grade: " + students);
        
        // Using Comparator (custom ordering)
        students.sort(Comparator.comparing(s -> s.getName()));
        System.out.println("Sorted by name: " + students);
        
        // Multiple criteria sorting
        students.sort(Comparator.comparing(Student::getName)
                               .thenComparing(Student::getGrade));
    }
}
```

**Q14: What are functional interfaces and lambda expressions? / ما هي الواجهات الوظيفية وتعبيرات لامبدا؟**

**English Answer:** Functional interfaces have exactly one abstract method. Lambda expressions provide concise syntax for implementing functional interfaces.

```java
// Functional interface
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

// Built-in functional interfaces
import java.util.function.*;

public class LambdaExample {
    public static void main(String[] args) {
        // Lambda expressions
        Calculator add = (a, b) -> a + b;
        Calculator multiply = (a, b) -> a * b;
        
        System.out.println("Add: " + add.calculate(5, 3));
        System.out.println("Multiply: " + multiply.calculate(5, 3));
        
        // Using built-in functional interfaces
        Predicate<String> isEmpty = s -> s.isEmpty();
        Function<String, Integer> stringLength = s -> s.length();
        Consumer<String> printer = s -> System.out.println(s);
        Supplier<String> supplier = () -> "Hello World";
        
        // Using with collections
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        names.stream()
             .filter(name -> name.length() > 3)
             .map(String::toUpperCase)
             .forEach(System.out::println);
    }
}
```

**Q15: Explain the Java Memory Model and Garbage Collection / اشرح نموذج الذاكرة في جافا وجمع القمامة**

**English Answer:** 

**Java Memory Model:**
```
JVM Memory Structure:
├── Method Area (Metaspace in Java 8+)
│   ├── Class metadata
│   ├── Method bytecode
│   └── Static variables
├── Heap Memory
│   ├── Young Generation
│   │   ├── Eden Space
│   │   ├── Survivor S0
│   │   └── Survivor S1
│   └── Old Generation (Tenured)
├── Stack Memory
│   ├── Method call frames
│   ├── Local variables
│   └── Partial results
└── PC (Program Counter) Register
```

**Garbage Collection Types:**
- **Serial GC**: Single-threaded, suitable for small applications
- **Parallel GC**: Multi-threaded, default for server applications
- **G1 GC**: Low-latency collector for large heaps
- **ZGC/Shenandoah**: Ultra-low latency collectors

```java
// Memory management example
public class MemoryExample {
    public static void main(String[] args) {
        // Stack memory - primitives and references
        int x = 10;
        String str = "Hello";
        
        // Heap memory - objects
        List<String> list = new ArrayList<>();
        list.add("Item 1");
        
        // Force garbage collection (not recommended in production)
        System.gc();
        
        // Memory information
        Runtime runtime = Runtime.getRuntime();
        System.out.println("Total memory: " + runtime.totalMemory());
        System.out.println("Free memory: " + runtime.freeMemory());
        System.out.println("Used memory: " + (runtime.totalMemory() - runtime.freeMemory()));
    }
}
```

### Practical Coding Questions / أسئلة البرمجة العملية

**Q16: Design a Banking System using OOP principles / صمم نظام مصرفي باستخدام مبادئ البرمجة الكائنية**

**English Answer:**

```java
// Abstract base class
abstract class Account {
    protected String accountNumber;
    protected String customerName;
    protected double balance;
    protected static int accountCounter = 1000;
    
    public Account(String customerName, double initialBalance) {
        this.accountNumber = "ACC" + (++accountCounter);
        this.customerName = customerName;
        this.balance = initialBalance;
    }
    
    // Abstract methods
    public abstract void withdraw(double amount) throws InsufficientBalanceException;
    public abstract void deposit(double amount);
    
    // Concrete methods
    public double getBalance() {
        return balance;
    }
    
    public String getAccountNumber() {
        return accountNumber;
    }
    
    public String getCustomerName() {
        return customerName;
    }
    
    public void displayAccountInfo() {
        System.out.println("Account: " + accountNumber);
        System.out.println("Customer: " + customerName);
        System.out.println("Balance: $" + String.format("%.2f", balance));
    }
}

// Savings Account implementation
class SavingsAccount extends Account {
    private static final double MIN_BALANCE = 100.0;
    private double interestRate;
    
    public SavingsAccount(String customerName, double initialBalance, double interestRate) {
        super(customerName, initialBalance);
        this.interestRate = interestRate;
    }
    
    @Override
    public void withdraw(double amount) throws InsufficientBalanceException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        
        if (balance - amount < MIN_BALANCE) {
            throw new InsufficientBalanceException(
                "Insufficient balance. Minimum balance required: $" + MIN_BALANCE
            );
        }
        
        balance -= amount;
        System.out.println("Withdrawn: $" + amount + " | New balance: $" + balance);
    }
    
    @Override
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        
        balance += amount;
        System.out.println("Deposited: $" + amount + " | New balance: $" + balance);
    }
    
    public void addInterest() {
        double interest = balance * interestRate / 100;
        balance += interest;
        System.out.println("Interest added: $" + interest + " | New balance: $" + balance);
    }
}

// Current Account implementation
class CurrentAccount extends Account {
    private double overdraftLimit;
    
    public CurrentAccount(String customerName, double initialBalance, double overdraftLimit) {
        super(customerName, initialBalance);
        this.overdraftLimit = overdraftLimit;
    }
    
    @Override
    public void withdraw(double amount) throws InsufficientBalanceException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        
        if (balance - amount < -overdraftLimit) {
            throw new InsufficientBalanceException(
                "Overdraft limit exceeded. Available balance: $" + (balance + overdraftLimit)
            );
        }
        
        balance -= amount;
        System.out.println("Withdrawn: $" + amount + " | New balance: $" + balance);
    }
    
    @Override
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        
        balance += amount;
        System.out.println("Deposited: $" + amount + " | New balance: $" + balance);
    }
}

// Custom exception
class InsufficientBalanceException extends Exception {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

// Bank management class
class Bank {
    private List<Account> accounts;
    private String bankName;
    
    public Bank(String bankName) {
        this.bankName = bankName;
        this.accounts = new ArrayList<>();
    }
    
    public void addAccount(Account account) {
        accounts.add(account);
        System.out.println("Account created successfully: " + account.getAccountNumber());
    }
    
    public Account findAccount(String accountNumber) {
        return accounts.stream()
                      .filter(acc -> acc.getAccountNumber().equals(accountNumber))
                      .findFirst()
                      .orElse(null);
    }
    
    public void displayAllAccounts() {
        System.out.println("\n=== " + bankName + " - All Accounts ===");
        for (Account account : accounts) {
            account.displayAccountInfo();
            System.out.println("------------------------");
        }
    }
    
    public double getTotalBalance() {
        return accounts.stream()
                      .mapToDouble(Account::getBalance)
                      .sum();
    }
}

// Demo class
public class BankingSystemDemo {
    public static void main(String[] args) {
        Bank bank = new Bank("Java National Bank");
        
        // Create accounts
        SavingsAccount savings = new SavingsAccount("Alice Johnson", 1000.0, 3.5);
        CurrentAccount current = new CurrentAccount("Bob Smith", 500.0, 1000.0);
        
        bank.addAccount(savings);
        bank.addAccount(current);
        
        try {
            // Perform transactions
            savings.deposit(200);
            savings.withdraw(150);
            savings.addInterest();
            
            current.deposit(300);
            current.withdraw(1200); // Using overdraft
            
            // Display account information
            bank.displayAllAccounts();
            System.out.println("Total bank balance: $" + bank.getTotalBalance());
            
        } catch (InsufficientBalanceException e) {
            System.out.println("Transaction failed: " + e.getMessage());
        } catch (IllegalArgumentException e) {
            System.out.println("Invalid input: " + e.getMessage());
        }
    }
}
```

**Q17: Implement a Generic Stack data structure / قم بتنفيذ هيكل بيانات Stack عام**

**English Answer:**

```java
import java.util.*;

public class GenericStack<T> {
    private List<T> stack;
    private int maxSize;
    
    // Constructor with unlimited size
    public GenericStack() {
        this.stack = new ArrayList<>();
        this.maxSize = Integer.MAX_VALUE;
    }
    
    // Constructor with maximum size
    public GenericStack(int maxSize) {
        this.stack = new ArrayList<>();
        this.maxSize = maxSize;
    }
    
    // Push element onto stack
    public void push(T element) throws StackOverflowException {
        if (stack.size() >= maxSize) {
            throw new StackOverflowException("Stack is full. Maximum size: " + maxSize);
        }
        stack.add(element);
    }
    
    // Pop element from stack
    public T pop() throws StackUnderflowException {
        if (isEmpty()) {
            throw new StackUnderflowException("Stack is empty");
        }
        return stack.remove(stack.size() - 1);
    }
    
    // Peek at top element without removing
    public T peek() throws StackUnderflowException {
        if (isEmpty()) {
            throw new StackUnderflowException("Stack is empty");
        }
        return stack.get(stack.size() - 1);
    }
    
    // Check if stack is empty
    public boolean isEmpty() {
        return stack.isEmpty();
    }
    
    // Get stack size
    public int size() {
        return stack.size();
    }
    
    // Check if stack is full
    public boolean isFull() {
        return stack.size() >= maxSize;
    }
    
    // Clear stack
    public void clear() {
        stack.clear();
    }
    
    // Convert stack to array
    public Object[] toArray() {
        return stack.toArray();
    }
    
    // Search for element (returns position from top, 1-based)
    public int search(T element) {
        int index = stack.lastIndexOf(element);
        if (index == -1) {
            return -1;
        }
        return stack.size() - index;
    }
    
    // Iterator for stack elements (from bottom to top)
    public Iterator<T> iterator() {
        return stack.iterator();
    }
    
    // Iterator for stack elements (from top to bottom)
    public Iterator<T> descendingIterator() {
        return new Iterator<T>() {
            private int index = stack.size() - 1;
            
            @Override
            public boolean hasNext() {
                return index >= 0;
            }
            
            @Override
            public T next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return stack.get(index--);
            }
        };
    }
    
    @Override
    public String toString() {
        if (isEmpty()) {
            return "Stack: []";
        }
        
        StringBuilder sb = new StringBuilder("Stack: [");
        for (int i = stack.size() - 1; i >= 0; i--) {
            sb.append(stack.get(i));
            if (i > 0) {
                sb.append(", ");
            }
        }
        sb.append("] <- top");
        return sb.toString();
    }
}

// Custom exceptions
class StackOverflowException extends Exception {
    public StackOverflowException(String message) {
        super(message);
    }
}

class StackUnderflowException extends Exception {
    public StackUnderflowException(String message) {
        super(message);
    }
}

// Demo and test class
class StackDemo {
    public static void main(String[] args) {
        // Integer stack
        GenericStack<Integer> intStack = new GenericStack<>(5);
        
        try {
            // Push elements
            intStack.push(10);
            intStack.push(20);
            intStack.push(30);
            System.out.println("After pushing: " + intStack);
            
            // Peek
            System.out.println("Top element: " + intStack.peek());
            System.out.println("Stack size: " + intStack.size());
            
            // Pop elements
            System.out.println("Popped: " + intStack.pop());
            System.out.println("After popping: " + intStack);
            
            // Search
            System.out.println("Position of 20: " + intStack.search(20));
            
            // String stack
            GenericStack<String> stringStack = new GenericStack<>();
            stringStack.push("First");
            stringStack.push("Second");
            stringStack.push("Third");
            
            System.out.println("\nString stack: " + stringStack);
            
            // Iterate from top to bottom
            System.out.println("Iterating from top to bottom:");
            Iterator<String> descIter = stringStack.descendingIterator();
            while (descIter.hasNext()) {
                System.out.println("- " + descIter.next());
            }
            
            // Custom object stack
            GenericStack<Person> personStack = new GenericStack<>();
            personStack.push(new Person("Alice", 25));
            personStack.push(new Person("Bob", 30));
            
            System.out.println("\nPerson stack: " + personStack);
            
        } catch (StackOverflowException | StackUnderflowException e) {
            System.out.println("Stack operation failed: " + e.getMessage());
        }
    }
}

// Helper class for demonstration
class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

**Q18: Create a thread-safe Singleton class / أنشئ فئة Singleton آمنة للخيوط**

**English Answer:**

```java
// Method 1: Eager Initialization (Thread-safe but not lazy)
class EagerSingleton {
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    private EagerSingleton() {
        // Private constructor
    }
    
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
    
    public void doSomething() {
        System.out.println("Eager Singleton instance: " + this.hashCode());
    }
}

// Method 2: Lazy Initialization with Synchronization (Thread-safe but slower)
class SynchronizedSingleton {
    private static SynchronizedSingleton instance;
    
    private SynchronizedSingleton() {
        // Prevent reflection-based instantiation
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to create instance");
        }
    }
    
    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
    
    public void doSomething() {
        System.out.println("Synchronized Singleton instance: " + this.hashCode());
    }
}

// Method 3: Double-Checked Locking (Thread-safe and efficient)
class DoubleCheckedSingleton {
    private static volatile DoubleCheckedSingleton instance;
    
    private DoubleCheckedSingleton() {
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to create instance");
        }
    }
    
    public static DoubleCheckedSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckedSingleton();
                }
            }
        }
        return instance;
    }
    
    public void doSomething() {
        System.out.println("Double-Checked Singleton instance: " + this.hashCode());
    }
}

// Method 4: Bill Pugh Solution (Initialization-on-demand holder idiom)
class BillPughSingleton {
    private BillPughSingleton() {
        if (SingletonHelper.INSTANCE != null) {
            throw new RuntimeException("Use getInstance() method to create instance");
        }
    }
    
    private static class SingletonHelper {
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }
    
    public static BillPughSingleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public void doSomething() {
        System.out.println("Bill Pugh Singleton instance: " + this.hashCode());
    }
}

// Method 5: Enum Singleton (Best approach - Thread-safe, prevents reflection and serialization issues)
enum EnumSingleton {
    INSTANCE;
    
    private int counter = 0;
    
    public void doSomething() {
        counter++;
        System.out.println("Enum Singleton instance: " + this.hashCode() + ", Counter: " + counter);
    }
    
    public int getCounter() {
        return counter;
    }
}

// Thread-safe Singleton with additional features
class AdvancedSingleton {
    private static volatile AdvancedSingleton instance;
    private final Map<String, Object> properties;
    private final long creationTime;
    
    private AdvancedSingleton() {
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to create instance");
        }
        this.properties = new ConcurrentHashMap<>();
        this.creationTime = System.currentTimeMillis();
        System.out.println("Advanced Singleton created at: " + new Date(creationTime));
    }
    
    public static AdvancedSingleton getInstance() {
        if (instance == null) {
            synchronized (AdvancedSingleton.class) {
                if (instance == null) {
                    instance = new AdvancedSingleton();
                }
            }
        }
        return instance;
    }
    
    public void setProperty(String key, Object value) {
        properties.put(key, value);
    }
    
    public Object getProperty(String key) {
        return properties.get(key);
    }
    
    public long getCreationTime() {
        return creationTime;
    }
    
    public void displayInfo() {
        System.out.println("Singleton instance: " + this.hashCode());
        System.out.println("Created at: " + new Date(creationTime));
        System.out.println("Properties: " + properties);
    }
    
    // Prevent cloning
    @Override
    protected Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException("Cannot clone singleton instance");
    }
}

// Test class to demonstrate thread safety
class SingletonTester {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Testing Thread Safety of Singletons ===");
        
        // Test with multiple threads
        ExecutorService executor = Executors.newFixedThreadPool(10);
        CountDownLatch latch = new CountDownLatch(10);
        
        // Test Double-Checked Singleton
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                try {
                    DoubleCheckedSingleton singleton = DoubleCheckedSingleton.getInstance();
                    singleton.doSomething();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        
        // Test Enum Singleton
        System.out.println("\n=== Testing Enum Singleton ===");
        EnumSingleton.INSTANCE.doSomething();
        EnumSingleton.INSTANCE.doSomething();
        EnumSingleton.INSTANCE.doSomething();
        
        // Test Advanced Singleton
        System.out.println("\n=== Testing Advanced Singleton ===");
        AdvancedSingleton advanced = AdvancedSingleton.getInstance();
        advanced.setProperty("version", "1.0");
        advanced.setProperty("author", "Java Developer");
        advanced.displayInfo();
        
        // Verify same instance
        AdvancedSingleton another = AdvancedSingleton.getInstance();
        System.out.println("Same instance? " + (advanced == another));
        
        executor.shutdown();
    }
}
```

### Summary and Best Practices / الملخص وأفضل الممارسات

**Key OOP Principles to Remember / المبادئ الرئيسية للبرمجة الكائنية:**

**English:**
1. **Encapsulation**: Keep data private and provide controlled access through methods
2. **Inheritance**: Use "is-a" relationship, favor composition over inheritance when appropriate
3. **Polymorphism**: Design interfaces that can work with multiple implementations
4. **Abstraction**: Hide complexity and expose only essential features

**Arabic / العربية:**
1. **التغليف**: اجعل البيانات خاصة ووفر وصول محكوم من خلال الطرق
2. **الوراثة**: استخدم علاقة "هو نوع من"، فضل التركيب على الوراثة عند الحاجة
3. **تعدد الأشكال**: صمم واجهات يمكنها العمل مع تنفيذات متعددة
4. **التجريد**: اخف التعقيد واعرض الميزات الأساسية فقط

**Best Practices / أفضل الممارسات:**

1. **Use meaningful names for classes, methods, and variables**
2. **Follow SOLID principles (when you learn design patterns later)**
3. **Handle exceptions appropriately**
4. **Use generics for type safety**
5. **Prefer composition over inheritance**
6. **Keep classes small and focused (Single Responsibility)**
7. **Use interfaces to define contracts**
8. **Make classes immutable when possible**
9. **Override equals(), hashCode(), and toString() when needed**
10. **Use proper synchronization for thread safety**

**Common Interview Tips / نصائح المقابلات الشائعة:**

**English:**
- Always provide code examples when explaining concepts
- Understand the "why" behind each OOP principle
- Be prepared to compare different approaches (ArrayList vs LinkedList, etc.)
- Know the trade-offs of different implementations
- Practice coding problems that combine multiple OOP concepts

**Arabic / العربية:**
- قدم أمثلة كود دائماً عند شرح المفاهيم
- افهم "لماذا" وراء كل مبدأ في البرمجة الكائنية
- كن مستعداً لمقارنة طرق مختلفة
- اعرف التنازلات في التنفيذات المختلفة
- تدرب على مشاكل البرمجة التي تجمع عدة مفاهيم كائنية

---

**Final Notes / ملاحظات أخيرة:**

This guide covers the essential Java OOP concepts that are commonly asked in interviews. Practice implementing these concepts with real-world examples and you'll be well-prepared for Java OOP interviews.

هذا الدليل يغطي المفاهيم الأساسية للبرمجة الكائنية في جافا التي تُسأل عادة في المقابلات. تدرب على تنفيذ هذه المفاهيم بأمثلة من الواقع وستكون مستعداً جيداً لمقابلات جافا الكائنية.

**Remember**: Understanding concepts is more important than memorizing code. Focus on the principles and practice applying them in different scenarios.

**تذكر**: فهم المفاهيم أهم من حفظ الكود. ركز على المبادئ وتدرب على تطبيقها في سيناريوهات مختلفة.

üéØ AWS Database Options for Spring Boot
Database Types in AWS:
bash

# 1. RDS (Relational Database) - SQL
‚úÖ PostgreSQL, MySQL, MariaDB, Oracle, SQL Server
‚úÖ Managed service (AWS handles backups, updates)
‚úÖ Perfect for Spring Boot JPA applications

# 2. DynamoDB (NoSQL) - Key-Value
‚úÖ Fully managed NoSQL
‚úÖ Auto-scaling, high performance
‚úÖ Good for unstructured data

# 3. Aurora (AWS Proprietary)
‚úÖ MySQL/PostgreSQL compatible
‚úÖ High performance, auto-scaling
‚úÖ More expensive but powerful

üóÑÔ∏è Option 1: AWS RDS (PostgreSQL) - Recommended
Step 1: Create RDS Database in AWS Console
text

AWS Console ‚Üí RDS ‚Üí Create database

1. Choose: PostgreSQL
2. Template: Free tier
3. Settings:
   - DB instance identifier: student-db
   - Master username: postgres
   - Master password: YourSecurePassword123!
4. Instance configuration: db.t3.micro (free tier)
5. Storage: 20 GB (free tier)
6. Connectivity: 
   - Public access: Yes (for learning)
   - VPC security group: Create new
7. Database authentication: Password authentication
8. Create database

Step 2: Get Connection Details
bash

# After creation, you'll get:
Endpoint: student-db.abc123.us-east-1.rds.amazonaws.com
Port: 5432
Database: postgres (default)
Username: postgres
Password: YourSecurePassword123!

Step 3: Spring Boot Configuration

pom.xml - Add Dependencies:
xml

<dependencies>
    <!-- Spring Boot Starter Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <!-- PostgreSQL Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>

application.properties:
properties

# AWS RDS PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://student-db.abc123.us-east-1.rds.amazonaws.com:5432/postgres
spring.datasource.username=postgres
spring.datasource.password=YourSecurePassword123!

# JPA Settings
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# Connection pool settings
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=20000

Step 4: Spring Boot Entity and Repository

Student Entity:
java

@Entity
@Table(name = "students")
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    // Constructors
    public Student() {}
    
    public Student(String name, String email) {
        this.name = name;
        this.email = email;
        this.createdAt = LocalDateTime.now();
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}

Student Repository:
java

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Custom query methods
    Optional<Student> findByEmail(String email);
    
    List<Student> findByNameContainingIgnoreCase(String name);
    
    @Query("SELECT s FROM Student s WHERE s.createdAt >= :date")
    List<Student> findStudentsCreatedAfter(@Param("date") LocalDateTime date);
}

Step 5: Controller Using RDS Database
java

@RestController
@RequestMapping("/api/students")
public class StudentController {
    
    @Autowired
    private StudentRepository studentRepository;
    
    @GetMapping
    public List<Student> getAllStudents() {
        return studentRepository.findAll();
    }
    
    @PostMapping
    public Student createStudent(@RequestBody Student student) {
        // Validate email doesn't exist
        if (studentRepository.findByEmail(student.getEmail()).isPresent()) {
            throw new RuntimeException("Email already exists");
        }
        return studentRepository.save(student);
    }
    
    @GetMapping("/search")
    public List<Student> searchStudents(@RequestParam String name) {
        return studentRepository.findByNameContainingIgnoreCase(name);
    }
    
    @GetMapping("/recent")
    public List<Student> getRecentStudents() {
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        return studentRepository.findStudentsCreatedAfter(yesterday);
    }
}

üóÇÔ∏è Option 2: AWS DynamoDB (NoSQL)
Step 1: Create DynamoDB Table
text

AWS Console ‚Üí DynamoDB ‚Üí Create table

1. Table name: students
2. Partition key: studentId (String)
3. Sort key: (leave empty for simple table)
4. Settings: Default
5. Create table

Step 2: Spring Boot Configuration for DynamoDB

pom.xml:
xml

<dependency>
    <groupId>io.github.boostchicken</groupId>
    <artifactId>spring-data-dynamodb</artifactId>
    <version>5.2.1</version>
</dependency>

application.properties:
properties

# AWS DynamoDB Configuration
amazon.dynamodb.endpoint=https://dynamodb.us-east-1.amazonaws.com
amazon.aws.accesskey=your-access-key
amazon.aws.secretkey=your-secret-key
amazon.aws.region=us-east-1

Step 3: DynamoDB Entity and Repository
java

@DynamoDBTable(tableName = "students")
public class StudentDynamo {
    
    private String studentId;
    private String name;
    private String email;
    private String createdAt;
    
    @DynamoDBHashKey
    @DynamoDBAutoGeneratedKey
    public String getStudentId() { return studentId; }
    public void setStudentId(String studentId) { this.studentId = studentId; }
    
    @DynamoDBAttribute
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    @DynamoDBAttribute
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    @DynamoDBAttribute
    public String getCreatedAt() { return createdAt; }
    public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
}

@Repository
public interface StudentDynamoRepository extends CrudRepository<StudentDynamo, String> {
}

üîß Local Development Setup
Using Docker for Local Database (Recommended):
bash

# Run PostgreSQL locally with Docker
docker run -d --name local-postgres \
  -e POSTGRES_DB=studentdb \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=1234 \
  -p 5432:5432 \
  postgres:15

application-local.properties:
properties

# Local PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/studentdb
spring.datasource.username=postgres
spring.datasource.password=1234

spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true

üåê Environment-Specific Configuration
Using Spring Profiles:

application-dev.properties (AWS RDS):
properties

spring.datasource.url=jdbc:postgresql://student-db.abc123.us-east-1.rds.amazonaws.com:5432/postgres
spring.datasource.username=postgres
spring.datasource.password=YourSecurePassword123!
spring.jpa.hibernate.ddl-auto=update

application-prod.properties:
properties

spring.datasource.url=jdbc:postgresql://prod-db.abc123.us-east-1.rds.amazonaws.com:5432/prod_db
spring.datasource.username=prod_user
spring.datasource.password=ProdSecurePassword456!
spring.jpa.hibernate.ddl-auto=validate

üöÄ Complete Deployment Example
Database Initialization Script:
sql

-- src/main/resources/schema.sql
CREATE TABLE IF NOT EXISTS students (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- src/main/resources/data.sql
INSERT INTO students (name, email) VALUES 
('John Doe', 'john@example.com'),
('Jane Smith', 'jane@example.com')
ON CONFLICT (email) DO NOTHING;

Database Configuration Class:
java

@Configuration
@EnableJpaRepositories(basePackages = "com.example.repository")
@EnableTransactionManagement
public class DatabaseConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource());
        em.setPackagesToScan("com.example.entity");
        
        JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);
        
        return em;
    }
    
    @Bean
    public PlatformTransactionManager transactionManager() {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory().getObject());
        return transactionManager;
    }
}

üìä Testing the Database Connection
Test Controller:
java

@RestController
public class DatabaseTestController {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private StudentRepository studentRepository;
    
    @GetMapping("/db-test")
    public Map<String, Object> testDatabase() {
        Map<String, Object> response = new HashMap<>();
        
        try {
            // Test connection
            Connection connection = dataSource.getConnection();
            response.put("database", connection.getMetaData().getDatabaseProductName());
            response.put("connected", true);
            connection.close();
            
            // Test repository
            response.put("studentCount", studentRepository.count());
            response.put("status", "SUCCESS");
            
        } catch (Exception e) {
            response.put("status", "ERROR");
            response.put("error", e.getMessage());
        }
        
        return response;
    }
}

üîí Security Best Practices
Using AWS Secrets Manager (Production):
java

@Configuration
public class AwsSecretsConfig {
    
    @Bean
    public DataSource dataSource() {
        // Get credentials from AWS Secrets Manager
        String dbUrl = "jdbc:postgresql://your-db-endpoint:5432/your-db";
        return DataSourceBuilder.create()
            .url(dbUrl)
            .username(getSecret("db-username"))
            .password(getSecret("db-password"))
            .build();
    }
    
    private String getSecret(String secretName) {
        // Implement AWS Secrets Manager client
        // This is a simplified example
        return "secret-from-aws";
    }
}

üéØ Summary:

For Spring Boot with AWS Databases:

    RDS PostgreSQL - Best for relational data with JPA

    DynamoDB - Best for high-scale, unstructured data

    Local Docker - Best for development and testing

Your application.properties is the key - just change the connection string to switch between local, development, and production databases!
